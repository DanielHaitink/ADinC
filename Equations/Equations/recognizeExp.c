/* recognizeExp.c, Gerard Renardel, 29 January 2014
 *
 * In this file a recognizer acceptExpression is definined that can recognize
 * arithmetical expressions generated by the following BNF grammar:
 *
 * <expression>  ::= <term> { '+'  <term> | '-' <term> }
 *
 * <term>       ::= <factor> { '*' <factor> | '/' <factor> }
 *
 * <factor>     ::= <number> | <identifier> | '(' <expression> ')'
 *
 * Input for the recognizer is the token list constructed by the scanner (in scanner.c).
 * For the recognition of a token list the method of *recursive descent* is used.
 * It relies on the use of three functions for the recognition and processing of
 * terms, factors and expressions, respectively.
 * These three functions are defined with mutual recursion, corresponding with the
 * structure of the BNF grammar.
 */

#include <stdio.h>  /* getchar, printf */
#include <stdlib.h> /* NULL */
#include "scanner.h"
#include "recognizeExp.h"
#include <string.h>

/* The functions acceptNumber, acceptIdentifier and acceptCharacter have as
 * (first) argument a pointer to an token list; moreover acceptCharacter has as
 * second argument a character. They check whether the first token
 * in the list is a number, an identifier or the given character, respectively.
 * When that is the case, they yield the value 1 and the pointer points to the rest of
 * the token list. Otherwise they yield 0 and the pointer remains unchanged.
 */

int acceptDegreeNumber(List *lp, int *degree){
    if (*lp != NULL && (*lp)->tt == Number) {
        if (((*lp)->t).number > *degree) {
            *degree=((*lp)->t).number;
        }
        *lp = (*lp)->next;
        return 1;
    }
    return 0;
}

int acceptNumber(List *lp) {
    if (*lp != NULL && (*lp)->tt == Number) {
        *lp = (*lp)->next;
        return 1;
    }
    return 0;
}

int acceptIdentifier(List *lp, char **varName) {
    printf("START ID %s\n", *varName);
    printf("%s\n", *varName);
    if (*lp != NULL && (*lp)->tt == Identifier ) {
        printf("FIRST IF ID\n");
        if (( (strcmp(*varName, "\0")==0) && ((strcmp(*varName, "\1")!=0) )) ||
            ( (strcmp(*varName, ((*lp)->t).identifier)==0) && (strcmp(*varName, "\1")!=0))){
            printf("SECOND IF ID varn:%s id:%s\n", *varName, ((*lp)->t).identifier);
            *varName =((*lp)->t).identifier;
            printf("%s\n", *varName);
        }
        else {
            printf("ELSE ID\n");
            *varName = "\1";
        }
        *lp = (*lp)->next;
        return 1;
    }
    return 0;
}

int acceptCharacter(List *lp, char c) {
    if (*lp != NULL && (*lp)->tt == Symbol && ((*lp)->t).symbol == c ) {
        *lp = (*lp)->next;
        return 1;
    }
    return 0;
}

/* The functions acceptFactor, acceptTerm and acceptExpression have as
 * argument a pointer to a token list. They check whether the token list
 * has an initial segment that can be recognized as factor, term or expression, respectively.
 * When that is the case, they yield the value 1 and the pointer points to the rest of
 * the token list. Otherwise they yield 0 and the pointer remains unchanged.
 */

int acceptTerm(List *lp, char **varName, int *degree) {
    if (acceptNumber(lp)) {
        if (acceptIdentifier(lp, varName)) {
            if (acceptCharacter(lp, '^')) {
                if (acceptDegreeNumber(lp, degree)) {
                    /* CHECK FOR NUMBER */
                    
                    return 1;
                }
                /* Just a '^' with no number followed by it */
                return 0;
            }
            return 1;
        }
        return 1;
    }
    return 0;
}

int acceptExpression(List *lp, char **varName, int *degree) {
    acceptCharacter(lp, '-');
    /* NOTE: THIS MAY CAUSE ERRORS ETC. MAYBE GIVES BACK NEXT POSITION IN LIST  */
    if ( !acceptTerm(lp, varName, degree) ) {
        return 0;
    }
    while ( acceptCharacter(lp,'+') || acceptCharacter(lp,'-') ) {
        if ( !acceptTerm(lp, varName, degree) ) {
            return 0;
        }
    } /* no + or -, so we reached the end of the expression */
    return 1;
}

int acceptEquation(List *lp, char **varName, int *degree) {
    return (acceptExpression(lp, varName, degree) && acceptCharacter(lp, '=') && acceptExpression(lp, varName, degree));
}


/* The next function can be used to demonstrate the recognizer.
 */

void recognizeExpressions() {
    int degree = -1;
    char *varName;
    char *ar;
    List tl, tl1;
    printf("give an equation: ");
    ar = readInput();
    while (ar[0] != '!') {
        tl = tokenList(ar);
        printf("the token list is ");
        printList(tl);
        tl1 = tl;
        degree = -1;
        varName = "\0";
        
        if ( acceptEquation(&tl1, &varName, &degree) && tl1 == NULL ) {
            if (*varName == '\1') {
                printf("this is an equation, but not in one variable\n");
            }
            else {
                if (degree == -1) {
                    printf("this is an equation in one variable of degree 1\n");
                }
                if (degree >= 0) {
                    printf("this is an equation in one variable of degree %d\n", degree);
                }
            }
        } else {
            printf("this is not an equation\n");
        }
        
        free(ar);
        freeTokenList(tl);
        printf("\ngive an equation: ");
        ar = readInput();
    }
    
    free(ar);
    printf("good bye\n");
}

